<!--

​    Licensed to the Apache Software Foundation (ASF) under one
​    or more contributor license agreements.  See the NOTICE file
​    distributed with this work for additional information
​    regarding copyright ownership.  The ASF licenses this file
​    to you under the Apache License, Version 2.0 (the
​    "License"); you may not use this file except in compliance
​    with the License.  You may obtain a copy of the License at
​    
​        http://www.apache.org/licenses/LICENSE-2.0
​    
​    Unless required by applicable law or agreed to in writing,
​    software distributed under the License is distributed on an
​    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
​    KIND, either express or implied.  See the License for the
​    specific language governing permissions and limitations
​    under the License.

-->

# 时间序列预测

## ARIMA
### 函数简介
本函数使用 ARIMA 模型拟合输入时间序列，并可预测后续的时间序列。

**函数名：** ARIMA

**输入序列：** 仅支持单个输入序列，类型为 INT32 / INT64 / FLOAT / DOUBLE。

**参数：**
+ `p`：自回归项数，应为大于等于 0 的整数。
+ `d`：差分阶数，应为大于等于 0 的整数。
+ `q`：滑动平均项数，应为大于等于 0 的整数。
+ `steps`：预测点的数量，默认为 0,即不做预测。
+ `output`

**输出序列：** 输出单个序列，类型为 DOUBLE。

**提示：** 函数忽略输入序列中的 NaN. 认为数据点是等间隔的。用户可以先进行重采样再进行分解。

### 模型介绍

ARIMA (Autoregressive Integrated Moving Average, Box-Jenkins, 差分整合移动平均自回归)模型是最常见的时间序列分析预测模型。它是由 AR (自回归)、MA (移动平均) 与差分共同组合而成的模型。ARIMA 模型共有三个参数，记为 ARIMA(d,p,q)，它是 ARMA(p,q) 模型的扩展。
下面将逐一介绍模型中的各个部分。

+ AR (自回归模型)

该模型假设时间序列的第 $t$ 项仅与该时刻前的 $p$ 项有关，且呈线性关系。记时间序列为 $$Y_t$$,  那么模型可以写为
$$
Y_t = \sum_{i=1}^{p}{\phi_i Y_{t-i}} + \phi_0 + \epsilon_t
$$

式中 $(\phi_0,\phi_1,\cdots,\phi_p)$ 表示线性模型的回归系数，$\epsilon_t$ 表示误差项。

自回归模型仅需指定阶数 $p$ 即可完成拟合。模型的准确性取决于时间序列的自相关性强弱。当自相关性足够强时，模型才有较好效果。衡量自相关性可以使用 ACF 函数计算。

+ MA (移动平均模型)

本模型可以写为
$$
Y_t = \theta_0 + \epsilon_t + \sum_{i=1}^{q}{\theta_i \epsilon_{t-i}}
$$
其中 $\theta_0$ 是序列的均值，$\epsilon_t$ 是 $t$ 时刻的误差项，$(\theta_1, \theta_2,\cdots,\theta_q)$ 是模型的参数。

也就是说，该模型总是以长度为 $q$ 的窗口内数据的误差确定下一项的值。

+ ARMA (移动平均自回归模型)

该模型是自回归模型应用于移动平均模型得到的模型。即先对原始序列取移动平均，再对得到的序列进行自回归分析。因此该模型有两个参数 $p,q$. 模型可以写为
$$
Y_t = \phi_0 + \sum_{i=1}^{p}{\phi_i Y_{t-i}} + \theta_0 + \epsilon_t + \sum_{i=1}^{q}{\theta_i \epsilon_{t-i}}
$$
​	若引入滞后算子 $L$, 使 $L^i$ 作用于某序列表示该序列滞后 $i$ 阶的项，模型可以表示成
$$
(1 - \sum_{i=1}^{p}{\phi_i L^i}) Y_t = (1 + \sum_{i=1}^{q}{\theta_i L^i})\epsilon_t + (\phi_0 + \theta_0)
$$

+ ARIMA (差分整合移动平均自回归模型)

对于非平稳时间序列，通常可以通过取 $d$ 阶差分的方式使其变为平稳序列。在 $d$ 阶差分序列上应用 ARMA 模型就得到了 ARIMA 模型。ARIMA(p,d,q) 可以写为
$$
(1-\sum_{i=1}^{p}{\phi_i L^i})(1-L)^d Y_t = (1+\sum_{i=1}^{q}{\theta_i L^i})\epsilon_t + (\phi_0 + \theta_0)
$$
可以看到，相较 ARMA 模型，仅仅是对将原始数据 $Y_t$ 替换为了 $d$ 阶差分 $(1-L)^d Y_t$.

在模型参数为低阶数时，存在一些特例，举例如下

+ ARIMA(0,1,0)	也即 MA(1), 形成简单的随机游走。
+ ARIMA(1,0,0)	也即 AR(1), 序列是指数变化的。
+ ARIMA(0,1,1)	形成简单指数平滑。若模型含有常数项，则为带有增长的简单指数平滑。
+ ARIMA(0,2,1)	形成线性指数平滑。

确定模型参数可以通过以下步骤进行：

+ 计算  $1$ 至 $d$ 阶差分，直至序列变为平稳序列。通常可使用 ADF (尚未实现)或 QLB 方法检验。
+ 对平稳序列计算 ACF 与 PACF. 对于 AR(p) 模型，PACF 在 $p$ 阶处截尾。对于 MA(q) 模型，ACF 在 $q$ 阶处截尾。对于一般情况，可以参考模型的 AIC 与 BIC 判断。
  + 截尾：指后续的值均缩小至 0 附近。

### 使用示例

输入序列

```
+-----------------------------+-------------------------+
|                         Time|root.udf.arima_test.value|
+-----------------------------+-------------------------+
|1970-01-01T08:00:00.001+08:00|                   6.7144|
|1970-01-01T08:00:00.002+08:00|                  13.3132|
|1970-01-01T08:00:00.003+08:00|                  16.1587|
|1970-01-01T08:00:00.004+08:00|                  17.3838|
|1970-01-01T08:00:00.005+08:00|                  16.0977|
|1970-01-01T08:00:00.006+08:00|                  13.8512|
|1970-01-01T08:00:00.007+08:00|                  10.5938|
|1970-01-01T08:00:00.008+08:00|                  11.2193|
|1970-01-01T08:00:00.009+08:00|                    7.058|
|1970-01-01T08:00:00.010+08:00|                   8.5565|
|1970-01-01T08:00:00.011+08:00|                  13.8039|
|1970-01-01T08:00:00.012+08:00|                  20.1125|
...
Total line number = 100
```

#### 输出预测结果

用于查询的 SQL 语句：

```sql
select arima(value, 'output' = 'forecast', 'p' = '5', 'q' = '2', 'd' = '1', 'steps' = '10') from root.udf.arima_test
```

输出序列

```
+-----------------------------+----------------------------------------------------------------------------------------------+
|Time                         |arima(root.udf.arima_test.value, "output"="forecast", "p"="5", "q"="2", "d"="1", "steps"="10")|
+-----------------------------+----------------------------------------------------------------------------------------------+
|1970-01-01T08:00:00.101+08:00|                                       																			204.9756001423199|
|1970-01-01T08:00:00.102+08:00|                                      																			 211.23778648605932|
|1970-01-01T08:00:00.103+08:00|                                      																			 215.67569955190612|
|1970-01-01T08:00:00.104+08:00|                                       																			218.4383755838573|
|1970-01-01T08:00:00.105+08:00|                                      																			 219.24618497706672|
|1970-01-01T08:00:00.106+08:00|                                      																			 218.79502918172784|
|1970-01-01T08:00:00.107+08:00|                                      																			 217.74178919857764|
|1970-01-01T08:00:00.108+08:00|                                      																			 217.02613122256972|
|1970-01-01T08:00:00.109+08:00|                                      																			 217.35635728236403|
|1970-01-01T08:00:00.110+08:00|                                      																			 219.21796483229522|
+-----------------------------+----------------------------------------------------------------------------------------------+
```

#### 输出拟合序列

用于查询的 SQL 语句：

```sql
select arima(value, 'output' = 'fittedSeries', 'p' = '5', 'q' = '2', 'd' = '1') from root.udf.arima_test
```

输出序列

```
+-----------------------------+--------------------------------------------------------------------------------+
|                         Time|arima(root.udf.arima_test.value,"output"="fittedSeries","p"="5","q"="2","d"="1")|
+-----------------------------+--------------------------------------------------------------------------------+
|1970-01-01T08:00:00.001+08:00|                                                               6.707685424801995|
|1970-01-01T08:00:00.002+08:00|                                                               9.491853068538257|
|1970-01-01T08:00:00.003+08:00|                                                              15.604679034225455|
|1970-01-01T08:00:00.004+08:00|                                                              18.510260154091885|
|1970-01-01T08:00:00.005+08:00|                                                               16.12112100536489|
|1970-01-01T08:00:00.006+08:00|                                                              12.807117929381503|
|1970-01-01T08:00:00.007+08:00|                                                               9.060778175873251|
|1970-01-01T08:00:00.008+08:00|                                                               3.705390352560703|
|1970-01-01T08:00:00.009+08:00|                                                                             NaN|
|1970-01-01T08:00:00.010+08:00|                                                              13.946317091812077|
|1970-01-01T08:00:00.011+08:00|                                                              12.420875560534379|
|1970-01-01T08:00:00.012+08:00|                                                              20.617405853736607|
...
Total line number = 100
```

## Decompose

### 函数简介

本函数使用传统加法或乘法模型将输入时间序列分解为趋势项、季节项、残差项之和。

**函数名：** Decompose

**输入序列：** 仅支持单个输入序列，类型为 INT32 / INT64 / FLOAT / DOUBLE。

**参数：**
+ `period`: 输入序列的周期长度，应当为大于 1 的整数。按数据点的个数计。
+ `method`: 分解使用的模型。 可以取 "additive" 或 "multiplicative". 默认值为 "additive".
+ `output`: 指示输出序列。可以取 "trend", "seasonal" 或 "residual". 默认值为 "trend".

**输出序列：** 输出单个序列，类型为 DOUBLE。

**提示：** 函数忽略输入序列中的 NaN. 认为数据点是等间隔的。用户可以先进行重采样再进行分解。

### 模型介绍

传统的时间序列分解模型认为时间序列数据是总体趋势与季节影响相互叠加的结果。季节影响是指数据周期性的变化，例如数据可能会以四个季节为一个周期波动，或十二个月为一个周期，等等。传统的模型将时序数据看作趋势项与季节项的和或者积，余项则是残差。记时间序列为 $$Y_t$$, 趋势项为 $$T_t$$, 季节项为 $$S_t$$, 残差项为 $$R_t$$, 那么传统的加法模型和乘法模型就可以写成
$$
Y_t = T_t + S_t + R_t\newline
Y_t = T_t * S_t * R_t
$$

在传统模型中，某时刻的趋势项仅由以该时刻为中心，窗口长度为周期长度的滑动平均值。（窗口长度为偶数时，窗口长度增加1，同时窗口最边缘的2个数的的权重降低二分之一）如果您想要得到线性趋势的拟合，请使用 Holt-Winters 函数。

模型的季节项由周期中同一相位的数据刨去了趋势项后做算术平均得到。例如，以四个季节为一个周期的数据中，将数据去除趋势项后，对所有春季的数据做算术平均，就有了所有春季时刻的季节项。因此，模型的季节项是周期重复的。

本模型的优点是模型简单，因此计算所需的时间很低。为获得更好的计算鲁棒性，您也可以使用 STL 函数分解。
模型的缺点是由于使用了滑动平均，原始序列的首尾各存在半个周期长度的数据无法分解。若您只想得到该模型中的趋势项，也可以使用数据画像中的 MvAvg 函数计算。

### 使用示例

#### 使用加法模型分解
输入序列：

```
+-----------------------------+---------------+
|                         Time|root.test.d1.s1|
+-----------------------------+---------------+
|1970-01-01T08:00:00.000+08:00|         315.71|
|1970-01-01T08:00:00.001+08:00|         317.45|
|1970-01-01T08:00:00.002+08:00|          317.5|
|1970-01-01T08:00:00.003+08:00|          317.1|
|1970-01-01T08:00:00.004+08:00|         315.86|
|1970-01-01T08:00:00.005+08:00|         314.93|
|1970-01-01T08:00:00.006+08:00|          313.2|
...
Total line number = 708
```

用于查询的 SQL 语句：

```sql
select decompose(s1, 'period' = '12', 'method' = 'additive', 'output' = 'trend') from root.test.d1
```

输出序列：

```
+-----------------------------+--------------------------------------------------------------------------------+
|                         Time|decompose(root.test.d1.s1, "period"="12", "method"="additive", "output"="trend")|
+-----------------------------+--------------------------------------------------------------------------------+
|1970-01-01T08:00:00.006+08:00|                                                              315.40916666666664|
|1970-01-01T08:00:00.007+08:00|                                                              315.46208333333334|
|1970-01-01T08:00:00.008+08:00|                                                                       315.50625|
|1970-01-01T08:00:00.009+08:00|                                                               315.5829166666667|
|1970-01-01T08:00:00.010+08:00|                                                              315.65500000000003|
|1970-01-01T08:00:00.011+08:00|                                                               315.6779166666667|
|1970-01-01T08:00:00.012+08:00|                                                              315.69916666666666|
...
Total line number = 696
```
用于查询的 SQL 语句：

```sql
select decompose(s1, 'period' = '12', 'method' = 'additive', 'output' = 'residual') from root.test.d1
```

输出序列：

```
+-----------------------------+-----------------------------------------------------------------------------------+
|                         Time|decompose(root.test.d1.s1, "period"="12", "method"="additive", "output"="residual")|
+-----------------------------+-----------------------------------------------------------------------------------+
|1970-01-01T08:00:00.006+08:00|                                                                 0.9237356321838588|
|1970-01-01T08:00:00.007+08:00|                                                                0.43947557471259424|
|1970-01-01T08:00:00.008+08:00|                                                               -0.11025862068976355|
|1970-01-01T08:00:00.009+08:00|                                                              -0.028714080459828817|
|1970-01-01T08:00:00.010+08:00|                                                               -0.07654454022997274|
|1970-01-01T08:00:00.011+08:00|                                                                0.01531609195390815|
|1970-01-01T08:00:00.012+08:00|                                                                -0.4370043103448982|
...
Total line number = 696
```
#### 使用乘法模型分解

输入序列：

```
+-----------------------------+---------------+
|                         Time|root.test.d1.s1|
+-----------------------------+---------------+
|1970-01-01T08:00:00.000+08:00|         315.71|
|1970-01-01T08:00:00.001+08:00|         317.45|
|1970-01-01T08:00:00.002+08:00|          317.5|
|1970-01-01T08:00:00.003+08:00|          317.1|
|1970-01-01T08:00:00.004+08:00|         315.86|
|1970-01-01T08:00:00.005+08:00|         314.93|
|1970-01-01T08:00:00.006+08:00|          313.2|
...
Total line number = 708
```

用于查询的 SQL 语句：

```sql
select decompose(s1, 'period' = '12', 'method' = 'multiplicative', 'output' = 'trend') from root.test.d1
```

输出序列：

```
+-----------------------------+--------------------------------------------------------------------------------------+
|                         Time|decompose(root.test.d1.s1, "period"="12", "method"="multiplicative", "output"="trend")|
+-----------------------------+--------------------------------------------------------------------------------------+
|1970-01-01T08:00:00.006+08:00|                                                                    315.40916666666664|
|1970-01-01T08:00:00.007+08:00|                                                                    315.46208333333334|
|1970-01-01T08:00:00.008+08:00|                                                                             315.50625|
|1970-01-01T08:00:00.009+08:00|                                                                     315.5829166666667|
|1970-01-01T08:00:00.010+08:00|                                                                    315.65500000000003|
|1970-01-01T08:00:00.011+08:00|                                                                     315.6779166666667|
|1970-01-01T08:00:00.012+08:00|                                                                    315.69916666666666|
...
Total line number = 696
```
用于查询的 SQL 语句：

```sql
select decompose(s1, 'period' = '12', 'method' = 'multiplicative', 'output' = 'residual') from root.test.d1
```

输出序列：

```
+-----------------------------+-----------------------------------------------------------------------------------------+
|                         Time|decompose(root.test.d1.s1, "period"="12", "method"="multiplicative", "output"="residual")|
+-----------------------------+-----------------------------------------------------------------------------------------+
|1970-01-01T08:00:00.006+08:00|                                                                        1.001927194431198|
|1970-01-01T08:00:00.007+08:00|                                                                       1.0003686308901425|
|1970-01-01T08:00:00.008+08:00|                                                                         0.99899519389507|
|1970-01-01T08:00:00.009+08:00|                                                                       0.9996499295945565|
|1970-01-01T08:00:00.010+08:00|                                                                       0.9997951326019452|
|1970-01-01T08:00:00.011+08:00|                                                                       1.0002873633298288|
|1970-01-01T08:00:00.012+08:00|                                                                       0.9990986638746625|
...
Total line number = 696
```

## Holt-Winters

### 函数简介

本函数使用 Holt-Winters 模型将输入时间序列分解为趋势项、季节项、残差项之和，并可预测后续数据。

**函数名：** HoltWinters

**输入序列：** 仅支持单个输入序列，类型为 INT32 / INT64 / FLOAT / DOUBLE。

**参数：**

+ `period`: 输入序列的周期长度，应当为大于 1 的整数。按数据点的个数计。
+ `method`: 分解使用的模型。 可以取 "additive", "multiplicative" 或 "linear". 默认值为 "additive".
+ `alpha`: Holt-Winters 模型的数据平滑因子，取值范围 [0,1], 默认值为 0.5.
+ `beta`: Holt-Winters 模型的趋势平滑因子，取值范围 [0,1], 默认值为 0.5.
+ `gamma`: Holt-Winters 模型的季节平滑因子，取值范围 [0,1], 仅在 `method` 不为 "linear" 时有效。默认值为 0.5.
+ `forecastNumber`: 需要预测的数据点个数。预测时间的时间戳按输入序列的平均时间间隔向后延伸。`method ` 取 "residual" 时不会额外输出（因为没有残差）。
+ `auto`: 布尔值，是否自动选取模型参数。若设置为 "true", 将使用 BOBYQA 方法优化，使模型的均方根误差最小，且输入的 `alpha`, `beta`, `gamma` 将作为初始搜索点。默认为 "true".
+ `maxEval`: 自动选取模型参数时的最大迭代次数。
+ `output`: 指示输出序列。可以取 "trend", "seasonal", "fitted" 或 "residual". 默认值为 "fitted".

**输出序列：** 输出单个序列，类型为 DOUBLE。

**提示：** 函数忽略输入序列中的 NaN. 认为数据点是等间隔的。用户可以先进行重采样再进行分解。

### 模型介绍

Holt-Winters 模型基于指数平滑方法（详情可参见 EMA）。为解决平滑数据的滞后问题，可以使用二次指数平滑（详情可参见 DEMA），也即 `method` = "linear" 的情况。记时间序列为  $$Y_t$$,趋势项为 $$T_t$$,季节项为 $$S_t$$,残差项为 $$R_t$$, 则模型可以写为
$$
Y_t = S_t + T_t + R_t
\newline
S_t = \alpha Y_t + (1 - \alpha)(S_{t-1}+T_{t-1})
\newline
T_t = \beta (s_t - s_{t-1}) + (1 - \beta)b_{t-1}
$$
时刻 $$t$$ 后的第 $$m$$ 个时刻的预测 $$F_{t+m}$$ 则为
$$
F_{t+m} = S_t + m * T_t
$$
若再考虑趋势的变化，那么可以使用三次指数平滑（详情可参见 TEMA）。它适用于趋势线性且周期 $$L$$ 固定的非平稳序列。其加法模型可以写成
$$
Y_t = T_t + S_t + R_t\newline
S_0 = Y_0\newline
S_t = \alpha(Y_t-C_{t-L}) + (1 - \alpha)(S_{t-1} + T_{t-1})\newline
T_t = \beta (S_t - S_{t-1}) + (1 - \beta)T_{t-1}\newline
C_t = \gamma (Y_t - S_{t-1} - T_{t-1}) + (1 - \gamma)C_{t-L}\newline
F_{t+m} = S_t + mT_t + C_{t-L+1+(m-1) \mod L}
$$
乘法模型可以写成
$$
Y_t = T_t * S_t * R_t\newline
S_0 = Y_0\newline
S_t = \alpha\frac{Y_t}{C_{t-L}} + (1 - \alpha)(S_{t-1} + T_{t-1})\newline
T_t = \beta (S_t - S_{t-1}) + (1 - \beta)T_{t-1}\newline
C_t = \gamma \frac{Y_t}{S_t} + (1 - \gamma)C_{t-L}\newline
F_{t+m} = (S_t + mT_t)C_{t-L+1+(m-1) \mod L}
$$

其中，$$C_t$$ 是表示趋势项线性递增的速度。

### 使用示例

#### 使用加法模型分解，自动确定参数

输入序列：

```
+-----------------------------+---------------+
|                         Time|root.test.d1.s1|
+-----------------------------+---------------+
|1970-01-01T08:00:00.000+08:00|         315.71|
|1970-01-01T08:00:00.001+08:00|         317.45|
|1970-01-01T08:00:00.002+08:00|          317.5|
|1970-01-01T08:00:00.003+08:00|          317.1|
|1970-01-01T08:00:00.004+08:00|         315.86|
|1970-01-01T08:00:00.005+08:00|         314.93|
|1970-01-01T08:00:00.006+08:00|          313.2|
...
Total line number = 708
```

用于查询的 SQL 语句：

```sql
select holtwinters(s1, 'period' = '12', 'method' = 'additive','forecastNumber'='10','output' = 'fitted') from root.test.d1
```

输出序列：

```
+-----------------------------+----------------------------------------------------------------------------------------------------------+
|                         Time|holtwinters(root.test.d1.s1, "period"="12", "method"="additive", "forecastNumber"="10", "output"="fitted")|
+-----------------------------+----------------------------------------------------------------------------------------------------------+
|1970-01-01T08:00:00.000+08:00|                                                                                         315.7702777777778|
|1970-01-01T08:00:00.001+08:00|                                                                                         317.5401997144624|
|1970-01-01T08:00:00.002+08:00|                                                                                        317.60462474676166|
|1970-01-01T08:00:00.003+08:00|                                                                                        317.21114452436507|
|1970-01-01T08:00:00.004+08:00|                                                                                         315.9736376452674|
|1970-01-01T08:00:00.005+08:00|                                                                                         315.0440856111198|
|1970-01-01T08:00:00.006+08:00|                                                                                        313.31350064811704|
...
Total line number = 718
```

用于查询的 SQL 语句：

```sql
select holtwinters(s1, 'period' = '12', 'method' = 'additive', 'output' = 'residual') from root.test.d1
```

输出序列：

```
+-----------------------------+-------------------------------------------------------------------------------------+
|                         Time|holtwinters(root.test.d1.s1, "period"="12", "method"="additive", "output"="residual")|
+-----------------------------+-------------------------------------------------------------------------------------+
|1970-01-01T08:00:00.000+08:00|                                                                 -0.06027777777779875|
|1970-01-01T08:00:00.001+08:00|                                                                  -0.0901997144624147|
|1970-01-01T08:00:00.002+08:00|                                                                 -0.10462474676165812|
|1970-01-01T08:00:00.003+08:00|                                                                 -0.11114452436504507|
|1970-01-01T08:00:00.004+08:00|                                                                 -0.11363764526737441|
|1970-01-01T08:00:00.005+08:00|                                                                 -0.11408561111977633|
|1970-01-01T08:00:00.006+08:00|                                                                 -0.11350064811705352|
...
Total line number = 696
```

## STL

### 函数简介

本函数使用STL方法将输入时间序列分解为趋势项、季节项、残差项之和。

**函数名：** STL

**输入序列：** 仅支持单个输入序列，类型为 INT32 / INT64 / FLOAT / DOUBLE。

**参数：**

+ `period`: 输入序列的周期长度，应当为大于 1 的整数。按数据点的个数计。
+ `swindow`: 季节项提取时的 LOESS 窗口长度（含滞后项），应当为奇数且大于等于 7. 缺省时使用周期回归。
+ `sdegree`: 季节项提取时局部拟合的多项式次数。应当为 0 或 1. 默认为 0.
+ `sjump`: 大于等于 1 的整数，用于提升季节平滑的计算速度。每隔`sjump`个点进行线性插值。默认值为 `ceil(swindow/10)`.
+ `twindow`: 趋势项提取时的 LOESS 窗口长度（含滞后项），应当为奇数。默认值为 `nextodd(ceil((1.5*period) / (1-(1.5/swindow))))`.
+ `tdegree`: 趋势项提取时局部拟合的多项式次数。应当为 0 或 1. 默认为 1.
+ `tjump`:  大于等于 1 的整数，用于提升趋势平滑的计算速度。每隔`tjump`个点进行线性插值。默认值为`ceil(twindow/10)`.
+ `lwindow`: 对每个子序列进行低通滤波时的 LOESS 窗口长度（含滞后项）。默认为不小于`period`的最小奇数.
+ `ldegree`: 子序列低通滤波时局部拟合的多项式次数。应当为 0 或 1. 默认等于`tdegree`.
+ `ljump`: 大于等于 1 的整数，用于提升低通滤波平滑的计算速度。每隔`ljump`个点进行线性插值。默认值为 `ceil(lwindow/10)`.
+ `robust`: 布尔值，指示是否在 LOESS 过程中使用鲁棒拟合。默认为 false.
+ `output`: 指示输出序列。可以取 "trend", "seasonal" 或 "residual". 默认值为 "trend".

**输出序列：** 输出单个序列，类型为 DOUBLE。

**提示：** 函数忽略输入序列中的 NaN. 认为数据点是等间隔的。用户可以先进行重采样再进行分解。

### 模型介绍
此处仅作简单介绍，本模型的详细内容请参见

Cleveland, R. B., Cleveland, W. S., McRae, J. E., & Terpenning, I. J. (1990). STL: A seasonal-trend decomposition procedure based on loess. Journal of Official Statistics, 6(1), 3–33.

STL 是 Seasonal and Trend decomposition using Loess 的缩写，采用加法模型。
相比传统模型，STL 使用 LOESS （局部加权回归）平滑趋势项。您可在任意线性回归的教材中找到 LOESS 的详细说明。
STL 相较于传统模型的优势是，允许季节成分随时间变化，同时对异常值不敏感（如图所示），且可以分解序列的首尾部分。

![stl-example](G:\iotdb\docs\zh\UserGuide\UDF-Library\stl-example.png)

本函数的参数较多，但仅`period`为必须提供。其余参数与 R 中的 stl 函数相同（仅省去了 "."）。
可以参考 [R 文档](https://search.r-project.org/R/refmans/stats/html/stl.html)。

### 使用示例

#### 指定周期长度分解

输入序列：

```
+-----------------------------+---------------+
|                         Time|root.test.d1.s1|
+-----------------------------+---------------+
|1970-01-01T08:00:00.000+08:00|         315.71|
|1970-01-01T08:00:00.001+08:00|         317.45|
|1970-01-01T08:00:00.002+08:00|          317.5|
|1970-01-01T08:00:00.003+08:00|          317.1|
|1970-01-01T08:00:00.004+08:00|         315.86|
|1970-01-01T08:00:00.005+08:00|         314.93|
|1970-01-01T08:00:00.006+08:00|          313.2|
...
Total line number = 708
```

用于查询的 SQL 语句：

```sql
select stl(s1, 'period' = '12', 'swindow' = '35', 'output' = 'trend') from root.test.d1
```

输出序列：

```
+-----------------------------+---------------------------------------------------------------------+
|                         Time|stl(root.test.d1.s1, "period"="12", "swindow"="35", "output"="trend")|
+-----------------------------+---------------------------------------------------------------------+
|1970-01-01T08:00:00.000+08:00|                                                    314.8471139496001|
|1970-01-01T08:00:00.001+08:00|                                                   314.94118165200905|
|1970-01-01T08:00:00.002+08:00|                                                   315.03524935441806|
|1970-01-01T08:00:00.003+08:00|                                                    315.1204665476064|
|1970-01-01T08:00:00.004+08:00|                                                   315.20568374079465|
|1970-01-01T08:00:00.005+08:00|                                                    315.2847651687474|
|1970-01-01T08:00:00.006+08:00|                                                   315.36384659670017|
...
Total line number = 708
```

用于查询的 SQL 语句：

```sql
select stl(s1, 'period' = '12', 'swindow' = '35', 'output' = 'residual') from root.test.d1
```

输出序列：

```
+-----------------------------+------------------------------------------------------------------------+
|                         Time|stl(root.test.d1.s1, "period"="12", "swindow"="35", "output"="residual")|
+-----------------------------+------------------------------------------------------------------------+
|1970-01-01T08:00:00.000+08:00|                                                    -0.37531049196786626|
|1970-01-01T08:00:00.001+08:00|                                                     0.14743669754562916|
|1970-01-01T08:00:00.002+08:00|                                                    -0.35080487369970115|
|1970-01-01T08:00:00.003+08:00|                                                     -0.2518283153173684|
|1970-01-01T08:00:00.004+08:00|                                                    -0.19777243845459225|
|1970-01-01T08:00:00.005+08:00|                                                       0.799142917146412|
|1970-01-01T08:00:00.006+08:00|                                                      0.6671653485419711|
...
Total line number = 708
```



## AR

### 函数简介

本函数使用自回归模型（Autoregressive model）拟合输入时间序列，计算自回归系数并预测后续数据。

**函数名：** AR

**输入序列：** 仅支持单个输入序列，类型为 INT32 / INT64 / FLOAT / DOUBLE。

**参数：**

+ p: 模型阶数，应当为正整数。
+ steps：预测步数。默认为1。
+ output: 指示输出序列。可以取 “coefficient”, “sequence”, “forecast” 或 “residual”。默认值为 “ coefficient ”。

**输出序列：** 输出单个序列，类型为 DOUBLE。输出序列可以为：

- 自回归系数
- 拟合序列
- 预测结果
- 残差

**提示：** 函数忽略输入序列中的 NaN。

### 使用示例

输入序列：

```
+-----------------------------+---------------+
|                         Time|root.test.d1.s1|
+-----------------------------+---------------+
|1970-01-01T08:00:00.000+08:00|       0.615367|
|1970-01-01T08:00:00.001+08:00|       1.300980|
|1970-01-01T08:00:00.002+08:00|      -0.218203|
|1970-01-01T08:00:00.003+08:00|      -0.976345|
|1970-01-01T08:00:00.004+08:00|      -0.531409|
|1970-01-01T08:00:00.005+08:00|       0.044977|
|1970-01-01T08:00:00.006+08:00|       1.048613|
...
Total line number = 300
```

#### 输出自回归系数

用于查询的 SQL 语句：

```sql
select ar(s1, 'p' = '5', 'output' = 'coefficient') from root.test.d1
```

输出序列：

```
+-----------------------------+-------------------------------------------+
|                         Time|ar(s1, 'p' = '5', 'output' = 'coefficient')|
+-----------------------------+-------------------------------------------+
|1970-01-01T08:00:00.000+08:00|                        0.25615431956708135|
|1970-01-01T08:00:00.001+08:00|                       -0.12861216153365415|
|1970-01-01T08:00:00.002+08:00|                        -0.3625302723212474|
|1970-01-01T08:00:00.003+08:00|                       -0.25106238043665424|
|1970-01-01T08:00:00.004+08:00|                        0.22001738996752368|
+-----------------------------+-------------------------------------------+
```

#### 输出拟合序列

用于查询的 SQL 语句：

```sql
select ar(s1, 'p' = '5', 'output' = 'sequence') from root.test.d1
```

输出序列：

```
+-----------------------------+----------------------------------------+
|                         Time|ar(s1, 'p' = '5', 'output' = 'sequence')|
+-----------------------------+----------------------------------------+
|1970-01-01T08:00:00.000+08:00|                                0.615367|
|1970-01-01T08:00:00.001+08:00|                                 1.30098|
|1970-01-01T08:00:00.002+08:00|                                0.759738|
|1970-01-01T08:00:00.003+08:00|                               -0.218203|
|1970-01-01T08:00:00.004+08:00|                               -0.976345|
|1970-01-01T08:00:00.005+08:00|                     -0.6886951481757273|
|1970-01-01T08:00:00.006+08:00|                     0.16404891626883172|
|1970-01-01T08:00:00.007+08:00|                      0.6557594681266603|
|1970-01-01T08:00:00.008+08:00|                      0.6525890550832002|
...
Total line number = 300
```

#### 输出预测结果

用于查询的 SQL 语句：

```sql
select ar(s1, 'p' = '5', 'output' = 'forecast', 'steps' = '5') from root.test.d1
```

输出序列：

```
+-----------------------------+-------------------------------------------------------+
|                         Time|ar(s1, 'p' = '5', 'output' = 'sequence', 'steps' = '5')|
+-----------------------------+-------------------------------------------------------+
|1970-01-01T08:00:00.000+08:00|                                   -0.30958964586848625|
|1970-01-01T08:00:00.001+08:00|                                     0.6191163629660078|
|1970-01-01T08:00:00.002+08:00|                                     0.9261617123785985|
|1970-01-01T08:00:00.003+08:00|                                    0.25702299037943743|
|1970-01-01T08:00:00.004+08:00|                                    -0.4136313859656312|
+-----------------------------+-------------------------------------------------------+
```

#### 输出残差

用于查询的 SQL 语句：

```sql
select ar(s1, 'p' = '5', 'output' = 'residual') from root.test.d1
```

输出序列：

```
+-----------------------------+----------------------------------------+
|                         Time|ar(s1, 'p' = '5', 'output' = 'residual')|
+-----------------------------+----------------------------------------+
|1970-01-01T08:00:00.000+08:00|                                     0.0|
|1970-01-01T08:00:00.001+08:00|                                     0.0|
|1970-01-01T08:00:00.002+08:00|                                     0.0|
|1970-01-01T08:00:00.003+08:00|                                     0.0|
|1970-01-01T08:00:00.004+08:00|                                     0.0|
|1970-01-01T08:00:00.005+08:00|                     0.15728614817572728|
|1970-01-01T08:00:00.006+08:00|                    -0.11907191626883172|
|1970-01-01T08:00:00.007+08:00|                      0.3928535318733397|
|1970-01-01T08:00:00.008+08:00|                     0.23926594491679976|
...
Total line number = 300
```

## SARIMA

### 函数简介

本函数使用 SARIMA 模型拟合输入时间序列，并可预测后续的时间序列。

**函数名：** SARIMA

**输入序列：** 仅支持单个输入序列，类型为 INT32 / INT64 / FLOAT / DOUBLE。

**参数：**

+ `p`：自回归项数，应为大于等于 0 的整数。
+ `d`：差分阶数，应为大于等于 0 的整数。
+ `q`：滑动平均项数，应为大于等于 0 的整数。
+ `steps`：预测点的数量，默认为 0,即不做预测。
+ `output`

**输出序列：** 输出单个序列，类型为 DOUBLE。

**提示：** 函数忽略输入序列中的 NaN. 认为数据点是等间隔的。用户可以先进行重采样再进行分解。

### 使用示例

输入序列

```
+-----------------------------+--------------------------+
|                         Time|root.udf.sarima_test.value|
+-----------------------------+--------------------------+
|2000-01-01T08:00:00.001+08:00|                     76273|
|2000-02-01T08:00:00.001+08:00|                     70994|
|2000-03-01T08:00:00.001+08:00|                     72795|
|2000-04-01T08:00:00.001+08:00|                     79561|
|2000-05-01T08:00:00.001+08:00|                     92584|
|2000-06-01T08:00:00.001+08:00|                    102644|
|2000-07-01T08:00:00.001+08:00|                    111101|
|2000-08-01T08:00:00.001+08:00|                    115467|
|2000-09-01T08:00:00.001+08:00|                    108515|
|2000-10-01T08:00:00.001+08:00|                    105465|
|2000-11-01T08:00:00.001+08:00|                     95800|
|2000-12-01T08:00:00.001+08:00|                     89610|
|2001-01-01T08:00:00.001+08:00|                     82219|
|2001-02-01T08:00:00.001+08:00|                     74830|
|2001-03-01T08:00:00.001+08:00|                     79845|
...
Total line number = 229
```

#### 输出预测结果

用于查询的 SQL 语句：

```sql
select sarima(value, 'output' = 'forecast', 'p' = '4', 'q' = '1', 'd' = '1', 'P' = '2', 'Q' = '1', 'D' = '1', 'steps' = '20') from root.udf.sarima_test
```

输出序列

```
+-----------------------------+--------------------------------------------------------------------------------------------------------------------------+
|                         Time|sarima(root.udf.arima_test.value, "output"="forecast", "p"="4", "q"="1", "d"="1", "P"="2", "Q"="1", "D"="1", "steps"="20")|
+-----------------------------+--------------------------------------------------------------------------------------------------------------------------+
|1970-01-01T08:00:00.101+08:00|                                                                                                         204.6209214376484|
|1970-01-01T08:00:00.102+08:00|                                                                                                        210.74299281324542|
|1970-01-01T08:00:00.103+08:00|                                                                                                        215.35740143689904|
|1970-01-01T08:00:00.104+08:00|                                                                                                          217.371156756569|
|1970-01-01T08:00:00.105+08:00|                                                                                                        217.25145744226663|
|1970-01-01T08:00:00.106+08:00|                                                                                                         215.3795312079138|
|1970-01-01T08:00:00.107+08:00|                                                                                                        212.85146352021266|
|1970-01-01T08:00:00.108+08:00|                                                                                                        210.56066874448348|
|1970-01-01T08:00:00.109+08:00|                                                                                                        209.67923065745984|
|1970-01-01T08:00:00.110+08:00|                                                                                                         210.9768721252065|
|1970-01-01T08:00:00.111+08:00|                                                                                                        214.51582186073625|
|1970-01-01T08:00:00.112+08:00|                                                                                                        219.96010034091134|
|1970-01-01T08:00:00.113+08:00|                                                                                                        226.45420989817816|
|1970-01-01T08:00:00.114+08:00|                                                                                                        232.91431794034597|
|1970-01-01T08:00:00.115+08:00|                                                                                                        238.23117706164606|
|1970-01-01T08:00:00.116+08:00|                                                                                                        241.59295703294964|
|1970-01-01T08:00:00.117+08:00|                                                                                                        242.69392439478455|
|1970-01-01T08:00:00.118+08:00|                                                                                                        241.75345589017832|
|1970-01-01T08:00:00.119+08:00|                                                                                                         239.5036928369731|
|1970-01-01T08:00:00.120+08:00|                                                                                                        236.99516916720017|
+-----------------------------+--------------------------------------------------------------------------------------------------------------------------+
```

#### 输出拟合序列

用于查询的 SQL 语句：

```sql
select sarima(value, 'output' = 'fittedSeries', 'p' = '4', 'q' = '1', 'd' = '1', 'P' = '2', 'Q' = '1', 'D' = '1') from root.udf.sarima_test
```

输出序列

```
+-----------------------------+-----------------------------------------------------------------------------------------------------------------+
|                         Time|sarima(root.udf.sarima_test.value, "output"="fittedSeries", "p"="4", "q"="1", "d"="1", "P"="2", "Q"="1", "D"="1")|
+-----------------------------+-----------------------------------------------------------------------------------------------------------------+
|2000-01-01T08:00:00.001+08:00|                                                                                                76238.88968989142|
|2000-02-01T08:00:00.001+08:00|                                                                                                71108.13399262477|
|2000-03-01T08:00:00.001+08:00|                                                                                                69090.67995088271|
|2000-04-01T08:00:00.001+08:00|                                                                                                77059.64596370702|
|2000-05-01T08:00:00.001+08:00|                                                                                                90584.17467718612|
|2000-06-01T08:00:00.001+08:00|                                                                                               104743.82111610338|
|2000-07-01T08:00:00.001+08:00|                                                                                               111689.32431887739|
|2000-08-01T08:00:00.001+08:00|                                                                                               114885.87184020969|
|2000-09-01T08:00:00.001+08:00|                                                                                               113847.66031971105|
|2000-10-01T08:00:00.001+08:00|                                                                                               100816.28616052556|
|2000-11-01T08:00:00.001+08:00|                                                                                                94384.27096121015|
|2000-12-01T08:00:00.001+08:00|                                                                                                89911.14264540777|
|2001-01-01T08:00:00.001+08:00|                                                                                                82148.07614332357|
|2001-02-01T08:00:00.001+08:00|                                                                                                78605.60378163874|
|2001-03-01T08:00:00.001+08:00|                                                                                                76442.34862369618|
|2001-04-01T08:00:00.001+08:00|                                                                                                85583.74539755435|
|2001-05-01T08:00:00.001+08:00|                                                                                               101929.42040485133|
|2001-06-01T08:00:00.001+08:00|                                                                                               114973.62891475212|
|2001-07-01T08:00:00.001+08:00|                                                                                               123878.71705603256|
|2001-08-01T08:00:00.001+08:00|                                                                                               131463.67176800632|
...
Total line number = 229
```

